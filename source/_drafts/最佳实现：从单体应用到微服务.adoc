title: 最佳实现：从单体应用到微服务
date: 2015-07-17 01:45:12
tags:
- 单体应用
- 微服务
---

____
During the last months many have claimed that a microservices architecture should always start with a monolith footnote:[http://martinfowler.com/bliki/MonolithFirst.html], among others Martin Fowler and Sam Newman, but Stefan Tilkov is convinced this is often wrong, building a well-structured monolith with cleanly separated modules that later may be moved out as microservices is in most cases extremely hard, if not impossible. 
* footnote:[http://martinfowler.com/articles/dont-start-monolith.html]
____

So what's the best practice for starting a new project?

At the beginning, the app has very few users. It's too hard to make every interface using RPC. The overhead of RPC would be waste computer resources. Every RPC server would request the same resource in a transaction. Besides there's much work to do in a microservices architecture, such as auto-deployment, monitoring, name server, service discovery. A new company with one or two engineers has to put its main resource on product development. It's no time to do so much Ops work.

I think out a solution for this. Let's consider using thrift as microservices RPC framework. Here's an example service spec.

[source, thrift]
----
struct User {
    1: i64 id,
    2: string name
}

service UserService {
    User get(1: i64 id);
}
----

Thrift program generate the following py code.

.Python Code
[source, thrift]
----
class Iface(object):

    def get(id):
        pass

class Client(Iface):

    def get(id):
        xxxxxx

class Processer(Iface):

    def get(id):
        xxxxxx
----

I implement a hanlder passing to `Processer`.

    class Handler(Iface):

        def get(id):
            return real user

    ThriftServer(Processer(Handler())).serve()

    client = Client()
    client.open()
    user = client.get(1)
    client.close()

I found `Client`, `Handler` and `Processer` are extend `Iface`. At the beginning,
I can use handler as client. As the app grouth, I can change handler to client using thrift RPC framework.
The biz code would be like:

    with ServiceContainer() as sc:
        user_service = sc.get('user')
        user = user_service.get(1)

My question is how can implement the ServiceContainer?
I do not want to modify the biz code and the service object should be thread safe,
taking care about open/close connection when using short connection PRC model,
taking care about request/release connection when using connection pool RPC model.



First of all, let's have a look at *Full Stack Web Frameworks* on which most of monolith apps are built.

> Rails is a web-application framework that includes everything needed to create database-backed web applications according to the Model-View-Controller (MVC) pattern.(from https://github.com/rails/rails)

Rails is the key app in ruby, starting the development of web application framework. Most of monolith apps were built on there full stack web application frameworks. Here's the first paragraph in Rails's GitHub Page. There are some words we should pay attention, such as MVC, "database-backed web application".
MVC shows a rails app is web-application, mostly a B/S web-application. The word "database-backed web applications" shows what rails builds. Database-backed shows the main datasource where a rails app  data come from. People use ActiveRecord pattern (one of ORM technology) to manage the database data, for example:

    class Product < ActiveRecord::Base
    end

    david = User.find_by(name: 'David')

In rails, ActiveRecord objects are inner data structure, database data structure, cache data structure, service interface data structure, even outer API data structure.
