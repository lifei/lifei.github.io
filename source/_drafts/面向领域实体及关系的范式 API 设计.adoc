title: 面向领域实体及关系的范式 API 设计
date: 2015-07-16 21:59:41
id: entity-relationship-based-api-design
tags:
- 领域实体
- API
- 范式
---

= 面向领域实体及关系的范式 API 设计

== 背景

很多年以前，大多数的 Web 开发是在开发网页应用，基本流程是解析参数、获取数据、渲染模版。市面上几乎每一款 Full Stack Web 框架都 MVC 架构，Controllers 将处理好的 Models 交给 Views 来渲染。进入移动时代后，随着网页应用转为 App，MVC 中的 V 不见了， 后端不再需要渲染模版了，UI 和交互全部都由 App 采用 Native 的方式来实现，而数据则通过 API 的方式从服务器传到客户端 App。Web 开发也慢慢地由网页应用开发转变为 API 开发。

『罗马不是一天建成的』，API 的设计从一开始就受到了 MVC 架构的影响，很多 API 的设计都是参考了 MVC 中『Controllers 将处理好的 Models 交给 Views』的设计，只是不再是『Controllers 将处理好的 Models 交给 Views』，而是服务器通过 API 将数据传给 App。

《<<X40,附录 A：订单列表页的例子>>》讲述了这样的一段演化经历。这种 API 设计非常常见，我们将之称为**『套模板 API 设计』**。一般的场景是服务端、客户端的研发同事照着 PM 给的页面原型图在一个僻静的会议室里一起设计 API。在这种 API 设计风格的基础上又演化出很多变种，加入了约定和要求，最有名的约定就是『嵌套外键关系』，譬如：link:https://github.com/interagent/http-api-design/blob/master/responses/nest-foreign-key-relations.md[HTTP API design guide extracted from work on the Heroku Platform API]
。

本文 

## 获取微博的例子

举例来说，有一个API需要返回指定话题下的微博列表（`http://api.com/tweets/?topic_id=10000001&offset=0&count=20`），其返回格式定义如下：

[source, json]
----
{
    "error": 0,
    "data": {
        "tweets": [{
            "id": 20000000,
            "content": "这是一条微博",
            "create_time": "2015-07-17 08:09:03",
            "images": [],
            "user": {
                "id": 100000001,
                "name": "张三",
                "avatar_url": "http://touxiao/zhangsan"
            },
            "comments": [{
                "id": 30000001,
                "content": "好微博",
                "create_time": "2015-07-17 08:09:03",
                "user": {
                    "id": 100000001,
                    "name": "张三",
                    "avatar_url": "http://touxiao/zhangsan"
                }
            }]
        }, ..., {
            "id": 20000001,
            "content": "这是第二条微博",
            "create_time": "2015-07-17 08:09:03",
            "images": [],
            "user": {
                "id": 100000002,
                "name": "李四",
                "avatar_url": "http://touxiao/lisi"
            }
        }],
        "offset": 20,
        "count": 20,
        "has_more": true
    }
}
----

其中，

.返回值含义
* `error`是错误码，`0`表示无错误。
* `data`表示数据域，所有的数据均在`data`数据域下：
** `tweets`表示微博的列表。
** `offset`为翻页标识。
** `count`表示每页多少条微博。
** `has_more`表示还可以继续翻页。

.关系图
----
{% plantuml %}

class User
class Tweet {
    user: User
    commentList: CommentList
}
class CommentList {
    comments: List<Comment>
    offset: int
    count: int
}
class TweetList {
    tweets: List<Tweet>
    offset: int
    count: int
}
class Comment

TweetList --> Tweet
Tweet --> CommentList : has one
Comment o-> User : belongs to
Tweet o--> User : belongs to
CommentList --> Comment: has many

{% endplantuml %}
----

.展示关系示意
[source, xml]
----
<TweetList tweets={tweets}>
    <Tweet tweet={tweet}>
        ...
        <User user={tweet.user} />
        <CommentList comments={tweet.comments}>
            <Comment comment={comment}>
                ...
                <User user={comment.user} />
            </Comment>
        </CommentList>
    </Tweet>
</TweetList>
----

优点：

1. 对象之间的关系明确
2. 依赖关系明确

缺点：

1. 对象相互嵌套
2. 同一对象可能会出现在各处

要实现这一个API，业务上基本需要实现4个函数。

1. `view`主函数，检查参数、依次调用相关函数，序列化结果。
2. `get_topic_tweets`主要业务函数，实现了获取某个话题下的微博功能。
3. `load`加载函数，加载打包API所需要的所有数据。
4. `pack`打包函数，将加载的数据按照API定义打包。

```python

def view(request):

    tweets = get_topic_tweets(request.args.get('topci_id'))
    loaded_tweets = load(tweets)
    packed_tweets = pack(loaded_tweets)
    return json.dumps(packed_tweets)

def get_topic_tweets(topic_id, offset=0, count=20):
    """
    获取指定topic下的tweets列表，按rate排序
    """
    return [(tweet_id, rate), (tweet_id, rate)]

def load(tweets):
    """
    加载打包需要的所有数据
    """

    tweet_ids = map(lamada x: x[0], tweets)
    tweet_dict = TweetDAO.get_multi(tweet_ids)

    user_ids = map(lamada x: x.user_id, tweet_dict.values())
    user_dict = UserDAO.get_multi(user_ids)

    ... load其他相关的实体，如标签、顶踩、关联的文章等等

    result = []
    for tweet_id, rate in tweets:
        tweet = tweet_dict[tweet_id]
        user = user_dict[tweet.user_id]
        ... 其他
        result.append(dict(tweet=tweet, user=user))

    return result

def pack(tweets):
    """
    打包成API约定的格式
    """

    result = []
    for tweet in tweets:
        data = {}

        pack_tweet(data, tweet)
        pack_user(data, tweet)
        ... pack 其他

        result.append(data)

    return result

```

## 一些讨论

这段代码本身其实没有什么问题，是一段非常标准的API实现代码。本文主要针对这个例子，讨论一下返回格式对API实现的影响，从而得出API格式的最佳实践。

### 问题一
假设还有一个API，是返回某个用户的微博列表（/tweets/?user_id=100000001），我们得到的结果将会是：

```json
{
    "error": 0,
    "data": {
        "tweets": [{
            "id": 20000000,
            "content": "这是一条微博",
            "create_time": "2015-07-17 08:09:03",
            "images": [],
            "user": {
                "id": 100000001,
                "name": "张三",
                "avatar_url": "http://touxiao/zhangsan"
            }
        }, ..., {
            "id": 20000001,
            "content": "这是第二条微博",
            "create_time": "2015-07-17 08:09:03",
            "images": [],
            "user": {
                "id": 100000001,
                "name": "张三",
                "avatar_url": "http://touxiao/zhangsan"
            }
        }],
        "offset": 20,
        "count": 20,
        "has_more": true
    }
}
```

所有的`user`域都是张三的信息，重复出现了20次，有点浪费。

### 问题二

随着业务的增长，一条微博的数据结构变得越来越复杂了，譬如：图片、视频、文章、组图、卡片、评论、
转发、各种统计等等等，中间还将穿插这各种版本信息，对应的`load`和`pack`代码将变成：

```
def load(tweets, version):
    load_tweets(tweets)
    load_users(tweets)

    if version >= 2:
        load_images(tweets)
        load_videos(tweets)
        load_articles(tweets)

    if version >= 4:
        load_group_images(tweets)

    if version >= 6:
        load_cards(tweets)
        load_comments(tweets)
        load_retweets(tweets)

    if version >= 7:
        load_stats(tweets)

def pack(tweets):
    pack_tweets(tweets)
    pack_users(tweets)

    if version >= 2:
        pack_images(tweets)
        pack_videos(tweets)
        pack_articles(tweets)

    if version >= 4:
        pack_group_images(tweets)

    if version >= 6:
        pack_cards(tweets)
        pack_comments(tweets)
        pack_retweets(tweets)

    if version >= 7:
        pack_stats(tweets)
```

在这个例子里面，`load`和`pack`要做到一致，`load`的内容不能比`pack`需要的少。

而且，`pack`函数有可能被100个view函数调用，维护开销会越来越高。

## 换一种API格式

```json
{
    "error": 0,
    "data": {
        "list": [[20000001, 10000], ..., [20000020, 10000]],
        "tweets": {
            "20000001": {
                "id": 20000001,
                "content": "这是一条微博",
                "create_time": "2015-07-17 08:09:03",
                "images": [],
                "user_id": 100000001
            }, "...": ...,
            "20000020": {
                "id": 20000020,
                "content": "这是第二条微博",
                "create_time": "2015-07-17 08:09:03",
                "images": [],
                "user_id": 100000001
            }
        },
        "users": {
            "100000001": {
                "id": 100000001,
                "name": "张三",
                "avatar_url": "http://touxiao/zhangsan"
            }
        },
        "images": ...,
        "videos": ...,
        "articles": ...,
        "...": ...,
        "offset": 20,
        "count": 20,
        "has_more": true
    }
}
```

有哪些变化：

1. 打包格式更程序员化，节省流量。
2. 实体之间的关系不再耦合紧密。
3. `load`即`pack`，不再需要二次组织。
4. 客户端可能需要做更多的工作。

## 省掉`pack`

`json.dumps`函数有一个参数为`cls`，可以让我们定义一个`Encoder`根据对象的类型做特定的序列化处理。

```python
class EntityEncoder(json.JSONEncoder):

    def default(self, obj):

        if isinstance(obj, Tweet):
            return dict(id=obj.id, content=obj.content, ...)

        elif isinstance(obj, User):
            return dict(id=obj.id, name=obj.name, avatar_url=obj.avatar_url)

        return json.JSONEncoder.default(self, obj)
```

从而实现`load`即`pack`的效果，`view`代码将变成：

```python

def view(request):

    tweets = get_topic_tweets(request.args.get('topci_id'))
    result = load(tweets)
    return json.dumps(result, cls=EntityEncoder)

```

这样做的一个好处是对本项目中的任何实体对象，全部采用统一的打包格式，要知道，统一一致就意味着生产力。
也对项目的抽象能力提了更高的要求：需要更好的抽象每个实体。

## Main Point

1. API返回的数据结构与领域实体的数据结构相同，不再进行嵌套等复杂封装。
2. 领域实体之间的关系通过关系域表示，譬如：`belongs to`, `has many` => {"id": ["ids"]}等。
3. API的定义与实体定义严格对应，在任何出现地方，故在API设计上，需要从实体作为出发点，把实体作为数据的组织单元。
4. 这样的API设计可以维护前后端数据结构的统一。


== 附录

[[X40]]

=== 附录 A：订单列表页的例子

假设有个页面，它是一个订单（Order）列表页，内容如下：

[source, html]
----
{{ title }}
{% for order in orders %}
{{ order.id }} {{ order.user.name }} {{ order.product.name }}
{% endfor %}
----

在 MVC 架构中，Controllers 需要为 Views 准备的如下格式的数据：

[source, python]
----
context = {
    "title": "我的订单列表",
    "orders": [{
        "id": 100001,
        "product": {
            "id": 200001,
            "name": "橘子",
        },
        "user": {
            "id": 300001,
            "name": "张三"
        }
    }]
}

return render_template("orders.html", **context)
----

现在，这个页面将由 Native App 来展示了，需要一个 API 来返回数据，我们该如何设计这个 API 呢？

等等，虽然上段数据是 Python 格式的，但好像和 JSON 非常像，我觉着它完全可以作为 API 返回给客户端 App。

[source, json]
----
{
    "title": "我的订单列表",
    "orders": [{
        "id": 100001,
        "product": {
            "id": 200001,
            "name": "橘子",
        },
        "user": {
            "id": 300001,
            "name": "张三"
        }
    }]
}
----

Python 代码将调整为：

[source, python]
----
context = {
    "title": "我的订单列表",
    "orders": [{
        "id": 100001,
        "product": {
            "id": 200001,
            "name": "橘子",
        },
        "user": {
            "id": 300001,
            "name": "张三"
        }
    }]
}

return jsonify(context)
----

哈哈，好像发现了个『窍门』，只需要将 `render_template` 给出 `jsonify` 就可以了。