title: 每个程序员都应该熟知的编程格言
date: 2015-08-27 17:51:26
id: programming-proverbs
tags:
---

== 无风不起浪 (There is no smoke without fire)

设计糟糕的代码通常表现以下 的一些现象：

* 巨大的类或者方法
* 大区块注释的代码
* 重复的逻辑
* 过多`if/else`层次嵌套

____
Poorly designed code tends to manifest itself through some common tell-tale signs.  Some examples of these are:

* Giant classes and/or functions
* Large blocks of commented out code
* Duplicated logic
* Deeply nested `if/else` blocks

Developers often refer to these as code smells, but personally, I think the term "code smoke" or "code fumes" is more appropriate as it implies a higher sense of urgency.  If you don't address the underlying problem it will come back to burn you later on.
____

== 预防为主，治疗为辅 (An ounce of prevention is worth a pound of cure）

程序员经常错误地认为高效率编码就是快速编码，很多程序员不经思索和设计就直接编写代码。
很不幸地是，这种 Leeroy Jenkins鲁莽做法将会编写出槽糕的代码，结果导致需要不断维护和修改代码，
甚至有可能这些槽糕的代码将会被替换掉。因此，编码效率不仅以编码的时间，而且还有调试代码的时间。
捡了芝麻丢了西瓜。磨刀不误砍柴工。

____
Toyota's assembly line of the 1980s was famously efficient due to its revolutionary approach towards defect prevention.  Each member of the assembly line was given the ability to halt production when they noticed a problem in their sector.  The idea was that it was better to halt production and fix the problem as early on as possible than to continue producing faulty units that would be tougher and more costly to fix/replace/recall later on.

Developers often make the faulty assumption that productivity = cranking out code quickly.  Many programmers dive straight into coding without a second thought towards design.  Unfortunately, this Leeroy Jenkins approach towards software development tends to lead to sloppy, fragile code that will need to be constantly monitored and patched — perhaps even replaced altogether down the line.  Ultimately, productivity must be measured not only in how much time is spent writing it, but also by how much time is spent debugging it.  A short term gain may prove to be a long term loss if one isn't careful.
____

== 种瓜得瓜，种豆得豆 （As you sow, so shall you reap)

《注重实效的程序员》一书中有这样一段话解释“破窗理论”：

不要留着“破窗户”（不良的设计、错误的决策或者糟糕的代码）不修。
发现一个就修一个，如果没有足够的时间进行适当的修复，就先把它保留起来。
或许你可以把出问题的代码放到注释中，或是显示“未实现”消息，或用虚拟数据加以替代。
采取一些措施，防止进一步的恶化，这表明局势尚在掌控之中。

我们见过整洁良好的系统在出现“破窗”之后立马崩溃。
虽然促使软件崩溃的原因还有其他因素（我们将在其他地方接触到），但（对“破窗”）置之不理，肯定会更快地加速系统崩溃。

简而言之，好的代码会促生好的代码，糟糕的代码也会促生糟糕的代码。
别低估了习惯的力量。没人想去整理糟糕的代码，同样没人想把完美的代码弄得一团糟。
写好你的代码，它才更可能经得住时间的考验。

____
"The Pragmatic Programmer" has this to say about the Broken Window theory:

Don't leave "broken windows" (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered. If there is insufficient time to fix it properly, then board it up. Perhaps you can comment out the offending code, or display a "Not Implemented" message, or substitute dummy data instead. Take some action to prevent further damage and to show that you're on top of the situation.

We've seen clean, functional systems deteriorate pretty quickly once windows start breaking. There are other factors that can contribute to software rot, and we'll touch on some of them elsewhere, but neglect accelerates the rot faster than any other factor.

In short, good code begets good code and bad code begets bad code.  Do not underestimate the power of inertia.  No one wants to be the one who has to clean up sloppy code, but neither does anyone want to be the one that makes a mess out of beautiful code.  Write it right and your code will have a far better chance at standing the test of time.
____

== 欲速则不达（Great haste makes great waste)

没时间对一个新功能进行适当的单元测试？好吧，你可以先完成一次测试运行，然后你就可以随时回来继续测试它。

当访问Y属性时，会不会碰到奇怪的对象引用错误？无论怎样，把代码放到try/catch语句块中。我们要钓到大鱼啦！

是不是似曾相识呢？这是因为我们在以前已经都做到了。并且在某些情况下、它是无可非议的。
毕竟，我们有最后期限，还得满足客户和经理。但不要过于频繁操作，否则你会发现你的代码不稳定，
有很多热修复、逻辑重复、未测试的方案和错误处理。最后，你要么是把事情草草做完，要么是把事情好好做完。

____
Managers, clients, and programmers are getting more impatient by the day.  Everything needs to be done and it needs to be done now.  Because of this, the temptation to throw together hacks and quick-fixes becomes very tough to resist.

No time to properly unit test a new feature?  Oh well, it works for the one test run you put it through.  You can always come back to it later!

Mysterious object referencing error when you try to access property Y?  Whatever, just throw a try/catch block around the code.  We've got bigger fish to fry!

Sound familiar?  It's because we've all done it at some point in time.  And in certain instances, it is justifiable.  After all, we have deadlines to meet and clients/managers to satisfy.  But do it too often and you'll soon find yourself with a very unstable code base full of hotfixes, duplicated logic, untested solutions, and porous error handling.  In the end, you have to strike a balance between getting things done and getting things done right.
____

== 三思而后行 (Look before you leap)

“敏捷开发”这个词最近被频繁滥用，经常被程序员用来掩饰他们在软件开发过程中的糟糕规划/设计阶段。
我们是设计者，看到产品朝正当方向有实质进展，我们理应高兴。
但意外的是，UML图和用例分析似乎并不能满足我们的愿望。
所以，在不知自己做什么的情况下或者不知自己身处何处时，我们开发人员经常就稀里糊涂地写代码了。

这就好比你要去吃饭，但你根本没有想好去哪里吃。
因为你太饿了，所以你迫不及待地找个餐馆，定个桌位。
然后你上车开车后沿途在想（找地方吃饭）。
只是，这样会耗费更多的时间，因为你要过较多的U型弯道，还在餐馆前停车，也许最后因等待时间过长而不吃了。
确切地说，你最后应该能找到地方吃饭，但你可能吃的饭并不是你想吃的，并且这样花费的时间，可能比你直接在想去的餐馆订餐所花的时间更长。

____
The term "Agile Development" is used and abused frequently these days, often as a way for programmers to justify ignoring the dreaded planning/designing phase of software development.  We are creators, and as such we derive pleasure from seeing actual progress made towards a finished product.  Surprisingly, UML diagrams and use case analysis just don't seem to satisfy that desire.  So, we developers often start off coding without any idea of what we are doing or where we are going.  It's like heading out for dinner when you haven't yet decided where you want to go.  You're hungry so you don't want to waste time finding a restaurant and booking a table.  Instead, you just hop in your car and figure you'll think of something along the way.  Only, it ends up taking you longer because you have to make a bunch of U-turns and stops at restaurants that end up having too long of a wait.  True, you'll probably find your way to food eventually, but you probably didn't end up with the meal you wanted and it probably took a lot more time and hassle than it would have had you just called and booked a reservation at a restaurant you wanted to go to.
____

== 沉默就是赞同（Silence is construed as approval）

我什么都没看见！没看见！

"破窗理论"与"变成惯性理论"有着宏观的联系。

编程社区就好像一个现实社区。每个作品都是一个开发者的缩影。
糟糕的代码发布的越多，就越容易反映现状。
如果你不去努力编写优秀、整洁和稳定的代码，那你每天都将和糟糕的代码相伴了。

同样地，如果你看到别人写出了糟糕的代码，你就要跟这个人提出来。
注意，这时候机智就应该用上场了，一般情况下，程序员都愿意承认他们在软件开发中还是有不懂的地方，并且会感谢你的好意。
互相帮助对大家都有利，而对问题视而不见，只会使问题一直存在。

____
This ties in with the theory on broken windows and programming inertia, only on a larger scale.

The programming community is just that, a community.  Each programmer is a reflection on the craft.  The more bad code that is released into the wild, the more it becomes the status quo.  If you don't make an effort to write good, clean,SOLID code, you will find yourself having to work with it on a day-to-day basis.

Likewise, if you see poorly designed code written by someone else, you should make the effort to bring it up with the creator. I should note, however, that tact ought to be employed in such a situation. In general, programmers are willing to admit that they do not know everything there is to know about software development and will appreciate the gesture.  We all benefit when we help each other out.  Turning a blind eye to problems only perpetuates them.
____

== 双鸟在林不如一鸟在手（A bird in the hand is worth two in the bush）

如果可以讨论系统架构和重构，那么就差找个时间把事情做完。为了使正常运作的东西更加简洁而做改动，权衡改动的利弊很重要。
当然了，简洁是一个理想目标， 但总会有可以通过重构改进的代码。
在编程世界中，为了代码不过时，会频繁简单改动代码。但有时候你又必须保证代码对客户有价值。
那么，你面临一个简单窘境：你不能一石二鸟。你在重构旧代码上所发时间越多，你编写新代码的时间就越少。
在及时改进代码和维护程序之间，也需要找到平衡点。

____
There is a time and place to discuss system architecture and refactoring opportunities, and a time to just get things done.
It is important to weigh the pros and cons of revamping something that already works just to make it cleaner.  It's an admirable goal, of course, but there will always be code that you want to restructure.  The programming world simply changes too frequently for code to not get outdated.  But at some point you have to provide value to your customers.  The simple fact remains: you can't do two things at once.  The more time you spend refactoring old code, the less time you spend creating new code.  Striking a balance is critical to enhancing as well as maintaining your application in a timely manner.
____

== 能力越大责任越大（With great power comes great responsibility）

毫无疑问，软件已成为我们生活中一个既基本又重要的一部分。正因如此，开发优秀软件格外重要。
乒乓球游戏中的Bug是一回事，航天飞机导向系统或者航空交通管制系统中的Bug是另外一回事。
Slashdot曾发表一文，讲述了单单Google News的一个小失误使一家公司股票蒸发11.4亿美元。
其他例子参见《软件Bug引发的十次严重后果》。
这些例子便说明了我们正行使着多大的权利。
你今天写的代码，无论你是否有意，说不定有朝一日在重要的应用程序中派上用场，这想想都令人害怕。
编写正确合格的代码吧！

____
Software has undoubtedly become an integral and vital part of our lives.  Because of this, practicing good software development is more crucial than ever.  It's one thing to have a bug in a game of Pong, it's another to have one in the guidance system of a space shuttle or air traffic control system.  Slashdot recently posted an article describing how a minor glitch in Google News singlehandedly evaporated $1.14 billion in shareholder wealth.  Events such as these demonstrate how much power we wield.  It's a little frightening to think that the code you write today, whether you intend it to or not, may one day be recycled and depended upon for mission-critical applications.  Write accordingly.
____
