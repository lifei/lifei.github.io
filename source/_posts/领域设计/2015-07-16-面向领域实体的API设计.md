title: 面向领域实体及关系的API设计
date: 2015-07-16 21:59:41
id: entity-relationship-based-api-design
tags:
- 领域实体
- API
---

日常的业务开发过程中，很大一部分工作是就是各种API开发。不论是基于何种协议，何种序列化方法，(只读)API的主要开发过程可以简单总结为：

1. 处理参数，检查合法性。
2. 根据参数获取相关数据。
3. 加载需要的实体内容。
4. 把加载的实体按照约定的格式打包、序列化、输出到API。

## 获取微博的例子

举例来说，有一个API需要返回指定话题下的微博列表(`http://somedomain/tweets/?topic_id=10000001&offset=0&count=20`)，其返回格式定义如下：

```json
{
    "error": 0,
    "data": {
        "tweets": [{
            "id": 20000000,
            "content": "这是一条微博",
            "create_time": "2015-07-17 08:09:03",
            "images": [],
            "user": {
                "id": 100000001,
                "name": "张三",
                "avatar_url": "http://touxiao/zhangsan"
            },
            "comments": [{
                "id": 30000001,
                "content": "好微博",
                "create_time": "2015-07-17 08:09:03",
                "user": {
                    "id": 100000001,
                    "name": "张三",
                    "avatar_url": "http://touxiao/zhangsan"
                }
            }]
        }, ..., {
            "id": 20000001,
            "content": "这是第二条微博",
            "create_time": "2015-07-17 08:09:03",
            "images": [],
            "user": {
                "id": 100000002,
                "name": "李四",
                "avatar_url": "http://touxiao/lisi"
            }
        }],
        "offset": 20,
        "count": 20,
        "has_more": true
    }
}
```

其中，
* `error`是错误码，`0`表示无错误。
* `data`表示数据域，所有的数据均在`data`数据域下：
    * `tweets`表示微博的列表。
    * `offset`为翻页标识。
    * `count`表示每页多少条微博。
    * `has_more`表示还可以继续翻页。

关系图

{% plantuml %}

class User
class Tweet {
    user: User
    commentList: CommentList
}
class CommentList {
    comments: List<Comment>
    offset: int
    count: int
}
class TweetList {
    tweets: List<Tweet>
    offset: int
    count: int
}
class Comment

TweetList --> Tweet
Tweet --> CommentList : has one
Comment o-> User : belongs to
Tweet o--> User : belongs to
CommentList --> Comment: has many

{% endplantuml %}

组件之间的关系

```
<TweetList tweets={tweets}>
    <Tweet tweet={tweet}>
        ...
        <User user={tweet.user} />
        <CommentList comments={tweet.comments}>
            <Comment comment={comment}>
                ...
                <User user={comment.user} />
            </Comment>
        </CommentList>
    </Tweet>
</TweetList>
```

优点：

1. 对象之间的关系明确
2. 依赖关系明确

缺点：

1. 对象相互嵌套
2. 同一对象可能会出现在各处

要实现这一个API，业务上基本需要实现4个函数。

1. `view`主函数，检查参数、依次调用相关函数，序列化结果。
2. `get_topic_tweets`主要业务函数，实现了获取某个话题下的微博功能。
3. `load`加载函数，加载打包API所需要的所有数据。
4. `pack`打包函数，将加载的数据按照API定义打包。

```python

def view(request):

    tweets = get_topic_tweets(request.args.get('topci_id'))
    loaded_tweets = load(tweets)
    packed_tweets = pack(loaded_tweets)
    return json.dumps(packed_tweets)

def get_topic_tweets(topic_id, offset=0, count=20):
    """
    获取指定topic下的tweets列表，按rate排序
    """
    return [(tweet_id, rate), (tweet_id, rate)]

def load(tweets):
    """
    加载打包需要的所有数据
    """

    tweet_ids = map(lamada x: x[0], tweets)
    tweet_dict = TweetDAO.get_multi(tweet_ids)

    user_ids = map(lamada x: x.user_id, tweet_dict.values())
    user_dict = UserDAO.get_multi(user_ids)

    ... load其他相关的实体，如标签、顶踩、关联的文章等等

    result = []
    for tweet_id, rate in tweets:
        tweet = tweet_dict[tweet_id]
        user = user_dict[tweet.user_id]
        ... 其他
        result.append(dict(tweet=tweet, user=user))

    return result

def pack(tweets):
    """
    打包成API约定的格式
    """

    result = []
    for tweet in tweets:
        data = {}

        pack_tweet(data, tweet)
        pack_user(data, tweet)
        ... pack 其他

        result.append(data)

    return result

```

## 一些讨论

这段代码本身其实没有什么问题，是一段非常标准的API实现代码。本文主要针对这个例子，讨论一下返回格式对API实现的影响，从而得出API格式的最佳实践。

### 问题一
假设还有一个API，是返回某个用户的微博列表 (/tweets/?user_id=100000001)，我们得到的结果将会是：

```json
{
    "error": 0,
    "data": {
        "tweets": [{
            "id": 20000000,
            "content": "这是一条微博",
            "create_time": "2015-07-17 08:09:03",
            "images": [],
            "user": {
                "id": 100000001,
                "name": "张三",
                "avatar_url": "http://touxiao/zhangsan"
            }
        }, ..., {
            "id": 20000001,
            "content": "这是第二条微博",
            "create_time": "2015-07-17 08:09:03",
            "images": [],
            "user": {
                "id": 100000001,
                "name": "张三",
                "avatar_url": "http://touxiao/zhangsan"
            }
        }],
        "offset": 20,
        "count": 20,
        "has_more": true
    }
}
```

所有的`user`域都是张三的信息，重复出现了20次，有点浪费。

### 问题二

随着业务的增长，一条微博的数据结构变得越来越复杂了，譬如：图片、视频、文章、组图、卡片、评论、
转发、各种统计等等等，中间还将穿插这各种版本信息，对应的`load`和`pack`代码将变成：

```
def load(tweets, version):
    load_tweets(tweets)
    load_users(tweets)

    if version >= 2:
        load_images(tweets)
        load_videos(tweets)
        load_articles(tweets)

    if version >= 4:
        load_group_images(tweets)

    if version >= 6:
        load_cards(tweets)
        load_comments(tweets)
        load_retweets(tweets)

    if version >= 7:
        load_stats(tweets)

def pack(tweets):
    pack_tweets(tweets)
    pack_users(tweets)

    if version >= 2:
        pack_images(tweets)
        pack_videos(tweets)
        pack_articles(tweets)

    if version >= 4:
        pack_group_images(tweets)

    if version >= 6:
        pack_cards(tweets)
        pack_comments(tweets)
        pack_retweets(tweets)

    if version >= 7:
        pack_stats(tweets)
```

在这个例子里面，`load`和`pack`要做到一致，`load`的内容不能比`pack`需要的少。

而且，`pack`函数有可能被100个view函数调用，维护开销会越来越高。

## 换一种API格式

```json
{
    "error": 0,
    "data": {
        "list": [[20000001, 10000], ..., [20000020, 10000]],
        "tweets": {
            "20000001": {
                "id": 20000001,
                "content": "这是一条微博",
                "create_time": "2015-07-17 08:09:03",
                "images": [],
                "user_id": 100000001
            }, "...": ...,
            "20000020": {
                "id": 20000020,
                "content": "这是第二条微博",
                "create_time": "2015-07-17 08:09:03",
                "images": [],
                "user_id": 100000001
            }
        },
        "users": {
            "100000001": {
                "id": 100000001,
                "name": "张三",
                "avatar_url": "http://touxiao/zhangsan"
            }
        },
        "images": ...,
        "videos": ...,
        "articles": ...,
        "...": ...,
        "offset": 20,
        "count": 20,
        "has_more": true
    }
}
```

有哪些变化：

1. 打包格式更程序员化，节省流量。
2. 实体之间的关系不再耦合紧密。
3. `load`即`pack`，不再需要二次组织。
4. 客户端可能需要做更多的工作。

## 省掉`pack`

`json.dumps`函数有一个参数为`cls`，可以让我们定义一个`Encoder`根据对象的类型做特定的序列化处理。

```python
class EntityEncoder(json.JSONEncoder):

    def default(self, obj):

        if isinstance(obj, Tweet):
            return dict(id=obj.id, content=obj.content, ...)

        elif isinstance(obj, User):
            return dict(id=obj.id, name=obj.name, avatar_url=obj.avatar_url)

        return json.JSONEncoder.default(self, obj)
```

从而实现`load`即`pack`的效果，`view`代码将变成：

```python

def view(request):

    tweets = get_topic_tweets(request.args.get('topci_id'))
    result = load(tweets)
    return json.dumps(result, cls=EntityEncoder)

```

这样做的一个好处是对本项目中的任何实体对象，全部采用统一的打包格式，要知道，统一一致就意味着生产力。
也对项目的抽象能力提了更高的要求：需要更好的抽象每个实体。

## Main Point

1. API返回的数据结构与领域实体的数据结构相同，不再进行嵌套等复杂封装。
2. 领域实体之间的关系通过关系域表示，譬如：`belongs to`, `has many` => {"id": ["ids"]}等。
3. API的定义与实体定义严格对应，在任何出现地方，故在API设计上，需要从实体作为出发点，把实体作为数据的组织单元。
4. 这样的API设计可以维护前后端数据结构的统一。
